================================================================================
                    07 - DTOs (Data Transfer Objects)
                         E-COMMERCE DE JOYER√çA
================================================================================

¬øQu√© es un DTO?
- Data Transfer Object (Objeto de Transferencia de Datos)
- Son clases simples que transportan datos entre capas
- NO tienen l√≥gica de negocio, solo getters y setters
- Se usan para transferir datos entre el backend y el frontend

================================================================================
¬øPOR QU√â USAR DTOs?
================================================================================

PROBLEMA 1: SEGURIDAD
Si retornas entidades directamente:

@GetMapping("/users/{id}")
public User getUser(@PathVariable Long id) {
    return userService.getById(id);
}

El frontend recibe TODO:
{
  "id": 1,
  "email": "juan@email.com",
  "password": "$2a$10$encrypted...",  // ‚ùå EXPONES LA CONTRASE√ëA
  "role": "ADMIN",                    // ‚ùå Informaci√≥n sensible
  "active": true,
  "createdAt": "2024-01-01"
}

Con DTO solo env√≠as lo necesario:
{
  "id": 1,
  "email": "juan@email.com",
  "firstName": "Juan",
  "lastName": "P√©rez"
}

PROBLEMA 2: CICLOS INFINITOS
Order tiene List<OrderItem>
OrderItem tiene Order
¬°Ciclo infinito al serializar a JSON! üîÑ

Order ‚Üí OrderItem ‚Üí Order ‚Üí OrderItem ‚Üí ...

Resultado: StackOverflowError

PROBLEMA 3: EXPONES LA ESTRUCTURA DE TU BASE DE DATOS
Si cambias la BD, cambias el contrato con el frontend

Hoy:
class Product {
    private Category category;  // Objeto completo
}

Ma√±ana:
class Product {
    private Long categoryId;    // Solo ID
}

El frontend SE ROMPE üí•

Con DTOs el contrato siempre es el mismo.

PROBLEMA 4: PERFORMANCE
Env√≠as DEMASIADOS datos innecesarios

Sin DTO (lista de productos):
{
  "id": 1,
  "name": "Anillo",
  "category": {
    "id": 1,
    "name": "Anillos",
    "description": "Descripci√≥n larga...",
    "imageUrl": "...",
    "active": true
  },
  "material": { /* objeto completo */ },
  "images": ["url1", "url2", "url3", "url4", "url5"],
  "reviews": [ /* 50 rese√±as completas */ ]
}

Con DTO (solo lo necesario):
{
  "id": 1,
  "name": "Anillo",
  "price": 5000,
  "categoryName": "Anillos",
  "mainImage": "url1",
  "averageRating": 4.5
}

PROBLEMA 5: VALIDACIONES DIFERENTES
Al CREAR producto:
- name es obligatorio
- price es obligatorio
- NO incluye ID (se genera autom√°ticamente)

Al ACTUALIZAR producto:
- name es opcional
- price es opcional
- S√ç incluye ID en la URL

Necesitas DTOs diferentes para cada operaci√≥n.

================================================================================
ALTERNATIVA: ANOTACIONES JACKSON
================================================================================

Puedes usar anotaciones de Jackson en vez de DTOs:

@JsonIgnore
- Ignora un campo al serializar a JSON

@Entity
public class User {
    private Long id;
    private String email;
    
    @JsonIgnore  // NO se env√≠a al frontend
    private String password;
}

@JsonProperty(access = Access.WRITE_ONLY)
- Solo recibe del frontend, NO env√≠a al frontend

@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
private String password;  // Recibe, pero NO env√≠a

@JsonManagedReference y @JsonBackReference
- Evita ciclos infinitos en relaciones bidireccionales

@Entity
public class Order {
    @OneToMany
    @JsonManagedReference  // Se serializa
    private List<OrderItem> items;
}

@Entity
public class OrderItem {
    @ManyToOne
    @JsonBackReference  // NO se serializa (evita ciclo)
    private Order order;
}

@JsonIgnoreProperties
- Ignora m√∫ltiples campos

@ManyToOne
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "password"})
private User user;

================================================================================
ESTRATEGIA RECOMENDADA: MIXTA
================================================================================

USA DTOs cuando:
‚úÖ Necesitas validaciones diferentes (crear vs actualizar)
‚úÖ Necesitas ocultar campos sensibles (User con password)
‚úÖ Necesitas estructuras diferentes (request vs response)
‚úÖ No corresponde a ninguna entidad (AuthResponse, ErrorResponse)

USA Anotaciones Jackson cuando:
‚úÖ La entidad es simple (Category, Material)
‚úÖ Solo necesitas ocultar algunos campos
‚úÖ Necesitas evitar ciclos en relaciones

================================================================================
DTOs QUE CREAMOS (7 archivos)
================================================================================

1. CreateOrderRequest.java
   - Para crear √≥rdenes desde el frontend
   - Tiene validaciones estrictas
   - Estructura diferente a Order (solo IDs de productos)
   
   Uso:
   POST /api/orders
   Body: CreateOrderRequest
   
   ¬øPor qu√©?
   - Validaciones espec√≠ficas
   - No incluye campos calculados (subtotal, totalAmount)
   - Solo IDs de productos, no objetos completos

2. OrderItemRequest.java
   - Items dentro de CreateOrderRequest
   - Valida productId y quantity
   
   Uso:
   Parte de CreateOrderRequest.items
   
   ¬øPor qu√©?
   - Validaciones espec√≠ficas por item
   - Estructura simple (solo ID + cantidad)

3. PaymentIntentResponse.java
   - Respuesta despu√©s de crear PaymentIntent en Stripe
   - Retorna clientSecret para el frontend
   
   Uso:
   POST /api/orders ‚Üí PaymentIntentResponse
   
   ¬øPor qu√©?
   - No corresponde a ninguna entidad
   - Espec√≠fico para integraci√≥n con Stripe
   - Combina info de Order + Stripe

4. ErrorResponse.java
   - Respuestas de error estandarizadas
   - Usado por @ControllerAdvice
   
   Uso:
   Cualquier error ‚Üí ErrorResponse
   
   ¬øPor qu√©?
   - Consistencia en respuestas de error
   - No corresponde a ninguna entidad
   - Mejor experiencia para el frontend

5. RegisterRequest.java
   - Para registrar nuevos usuarios
   - Validaciones espec√≠ficas de registro
   
   Uso:
   POST /api/auth/register
   Body: RegisterRequest
   
   ¬øPor qu√©?
   - Validaciones diferentes a User
   - No incluye role, active, createdAt
   - Password debe tener m√≠nimo 6 caracteres

6. LoginRequest.java
   - Para login de usuarios
   - Solo email y password
   
   Uso:
   POST /api/auth/login
   Body: LoginRequest
   
   ¬øPor qu√©?
   - Solo necesita 2 campos
   - Estructura diferente a User
   - Validaciones simples

7. AuthResponse.java
   - Respuesta de login/registro
   - Retorna JWT token + info del usuario
   
   Uso:
   POST /api/auth/login ‚Üí AuthResponse
   POST /api/auth/register ‚Üí AuthResponse
   
   ¬øPor qu√©?
   - Combina User + JWT token
   - No corresponde a ninguna entidad
   - Info que el frontend necesita guardar

================================================================================
DTOs QUE NO CREAMOS (usamos entidades con anotaciones)
================================================================================

‚ùå CategoryDTO
Raz√≥n: Category es simple, usamos @JsonIgnore si necesitamos

‚ùå MaterialDTO
Raz√≥n: Material es simple, sin relaciones complejas

‚ùå ProductDTO
Raz√≥n: Product funciona bien con @JsonIgnoreProperties

‚ùå OrderDTO
Raz√≥n: Order funciona bien con @JsonManagedReference

‚ùå ReviewDTO
Raz√≥n: Review funciona bien con @JsonIgnoreProperties

================================================================================
CU√ÅNDO USAR QU√â
================================================================================

Caso                      | Soluci√≥n                    | Raz√≥n
--------------------------|-----------------------------|------------------------
Crear orden               | CreateOrderRequest (DTO)    | Validaciones diferentes
Ver orden                 | Order (entidad)             | @JsonManagedReference
Crear usuario             | RegisterRequest (DTO)       | Sin role/active
Ver usuario               | User (entidad)              | @JsonIgnore en password
Login                     | LoginRequest (DTO)          | Solo email + password
Respuesta login           | AuthResponse (DTO)          | User + JWT token
Stripe payment            | PaymentIntentResponse (DTO) | No es entidad
Ver producto              | Product (entidad)           | @JsonIgnoreProperties
Ver categor√≠a             | Category (entidad)          | Simple
Errores                   | ErrorResponse (DTO)         | Estandarizaci√≥n

================================================================================
EJEMPLO COMPLETO EN CONTROLLER
================================================================================

OrderController usando DTOs:

@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    private final OrderService orderService;
    
    // Crear orden - USA DTO
    @PostMapping
    public ResponseEntity<Order> createOrder(
        @Valid @RequestBody CreateOrderRequest request
    ) {
        Order created = orderService.createOrder(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    // ‚úÖ Recibe: CreateOrderRequest (DTO)
    // ‚úÖ Retorna: Order (entidad con @JsonManagedReference)
    
    // Ver orden - USA ENTIDAD
    @GetMapping("/{id}")
    public ResponseEntity<Order> getOrderById(@PathVariable Long id) {
        Order order = orderService.getOrderById(id);
        return ResponseEntity.ok(order);
    }
    // ‚úÖ Retorna: Order (entidad)
    // ‚úÖ NO necesita DTO
}

ProductController SIN DTOs:

@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    private final ProductService productService;
    
    // Ver productos - USA ENTIDAD directamente
    @GetMapping
    public ResponseEntity<List<Product>> getAllProducts() {
        List<Product> products = productService.getAllActiveProducts();
        return ResponseEntity.ok(products);
    }
    // ‚úÖ Retorna: List<Product> (entidades)
    // ‚úÖ NO necesita DTO porque @JsonIgnoreProperties maneja todo
}

CategoryController SIN DTOs:

@RestController
@RequestMapping("/api/categories")
public class CategoryController {
    
    private final CategoryService categoryService;
    
    @GetMapping
    public ResponseEntity<List<Category>> getAllCategories() {
        List<Category> categories = categoryService.getAllCategories();
        return ResponseEntity.ok(categories);
    }
    // ‚úÖ Retorna: List<Category> (entidades)
    // ‚úÖ NO necesita DTO porque Category es simple
}

================================================================================
ESTRUCTURA DE ARCHIVOS
================================================================================

src/main/java/com/joyeria/dto/
‚îú‚îÄ‚îÄ CreateOrderRequest.java      ‚úÖ Crear √≥rdenes
‚îú‚îÄ‚îÄ OrderItemRequest.java        ‚úÖ Items de la orden
‚îú‚îÄ‚îÄ PaymentIntentResponse.java   ‚úÖ Respuesta Stripe
‚îú‚îÄ‚îÄ ErrorResponse.java           ‚úÖ Errores
‚îú‚îÄ‚îÄ RegisterRequest.java         ‚úÖ Registro
‚îú‚îÄ‚îÄ LoginRequest.java            ‚úÖ Login
‚îî‚îÄ‚îÄ AuthResponse.java            ‚úÖ Respuesta auth

================================================================================
VALIDACIONES EN DTOs
================================================================================

Anotaciones de Jakarta Validation:

@NotNull
- El campo NO puede ser null
Ejemplo: @NotNull private Long productId;

@NotBlank
- String NO puede ser null, vac√≠o ni solo espacios
Ejemplo: @NotBlank private String email;

@NotEmpty
- Colecci√≥n NO puede ser null ni vac√≠a
Ejemplo: @NotEmpty private List<OrderItemRequest> items;

@Email
- Valida formato de email
Ejemplo: @Email private String email;

@Size
- Valida longitud de String o tama√±o de colecci√≥n
Ejemplo: @Size(min = 2, max = 100) private String name;

@Min / @Max
- Valida valor m√≠nimo/m√°ximo de n√∫meros
Ejemplo: @Min(1) private Integer quantity;

@Valid
- Valida objetos anidados
Ejemplo: @Valid private List<OrderItemRequest> items;

Ejemplo completo:

@Getter
@Setter
public class CreateOrderRequest {
    
    @NotEmpty(message = "La orden debe tener al menos un producto")
    @Valid  // Valida cada OrderItemRequest dentro de la lista
    private List<OrderItemRequest> items;
    
    @NotBlank(message = "El email es requerido")
    @Email(message = "Email inv√°lido")
    private String customerEmail;
    
    @NotBlank(message = "El nombre es requerido")
    @Size(min = 2, max = 100, message = "Entre 2 y 100 caracteres")
    private String customerName;
}

================================================================================
C√ìMO FUNCIONA LA VALIDACI√ìN
================================================================================

1. Cliente env√≠a JSON:
POST /api/orders
{
  "items": [],  // ‚ùå Lista vac√≠a
  "customerEmail": "no-es-email",  // ‚ùå Email inv√°lido
  "customerName": "J"  // ‚ùå Muy corto
}

2. Spring valida autom√°ticamente con @Valid:
@PostMapping
public ResponseEntity<Order> createOrder(
    @Valid @RequestBody CreateOrderRequest request  // ‚Üê @Valid activa validaciones
) {
    // Si hay errores, NO llega aqu√≠
}

3. Si hay errores, Spring retorna 400 BAD REQUEST:
{
  "timestamp": "2024-02-17T10:00:00",
  "status": 400,
  "error": "Bad Request",
  "message": "La orden debe tener al menos un producto"
}

4. Si todo es v√°lido, contin√∫a normalmente.

================================================================================
CONVERSI√ìN DTO ‚Üí ENTIDAD
================================================================================

En el Service conviertes DTO a Entidad:

@Service
public class OrderService {
    
    public Order createOrder(CreateOrderRequest request) {
        // 1. Crear entidad Order
        Order order = new Order();
        order.setCustomerEmail(request.getCustomerEmail());
        order.setCustomerName(request.getCustomerName());
        // ...
        
        // 2. Procesar items
        for (OrderItemRequest itemReq : request.getItems()) {
            Product product = productService.getById(itemReq.getProductId());
            
            OrderItem item = new OrderItem();
            item.setProduct(product);
            item.setQuantity(itemReq.getQuantity());
            item.setPriceAtPurchase(product.getPrice());
            
            order.addItem(item);
        }
        
        // 3. Guardar
        return orderRepository.save(order);
    }
}

================================================================================
BUENAS PR√ÅCTICAS
================================================================================

‚úÖ Usa DTOs cuando necesites:
   - Validaciones diferentes
   - Ocultar campos sensibles
   - Estructuras diferentes (request vs response)

‚úÖ Usa anotaciones Jackson cuando:
   - La entidad es simple
   - Solo necesitas ocultar algunos campos

‚úÖ Nombra los DTOs descriptivamente:
   - CreateOrderRequest (no OrderDTO)
   - RegisterRequest (no UserCreateDTO)
   - AuthResponse (no LoginResponseDTO)

‚úÖ Valida SIEMPRE con @Valid en el Controller

‚úÖ Convierte DTO ‚Üí Entidad en el Service, NO en el Controller

‚úÖ Documenta por qu√© cada DTO existe

‚ùå NO uses DTOs para todo (sobrecarga innecesaria)

‚ùå NO pongas l√≥gica de negocio en DTOs (solo datos)

‚ùå NO conviertas DTO ‚Üí Entidad en el Controller

‚ùå NO retornes entidades con informaci√≥n sensible

================================================================================
RESUMEN
================================================================================

DTOs son clases para transferir datos entre capas
- ‚úÖ Protegen informaci√≥n sensible
- ‚úÖ Evitan ciclos infinitos
- ‚úÖ Desacoplan frontend de tu BD
- ‚úÖ Permiten validaciones espec√≠ficas

Estrategia mixta (DTOs + Anotaciones Jackson):
- ‚úÖ DTOs solo donde realmente aportan valor (7 archivos)
- ‚úÖ Anotaciones Jackson para el resto
- ‚úÖ Balance: simplicidad + buenas pr√°cticas

DTOs creados:
1. CreateOrderRequest - Crear √≥rdenes con validaciones
2. OrderItemRequest - Items de la orden
3. PaymentIntentResponse - Respuesta de Stripe
4. ErrorResponse - Errores estandarizados
5. RegisterRequest - Registro de usuarios
6. LoginRequest - Login de usuarios
7. AuthResponse - Respuesta de autenticaci√≥n

================================================================================
                            FIN DE APUNTES
================================================================================
