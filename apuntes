================================================================================
                    APUNTES - SPRING BOOT + JPA + POSTGRESQL
                         E-COMMERCE DE JOYER√çA
================================================================================

üìö √çNDICE:
1. Anotaciones JPA (Entidades)
2. Anotaciones Lombok
3. Tipos de datos importantes
4. Relaciones entre tablas
5. Spring Data JPA - Repositories
6. Convenciones de nombres en m√©todos
7. Consultas personalizadas con @Query
8. Buenas pr√°cticas

================================================================================
1. ANOTACIONES JPA (ENTIDADES)
================================================================================

@Entity
- Marca una clase como tabla de base de datos
- Cada instancia = una fila en la tabla
Ejemplo: @Entity public class Product { ... }

@Table(name = "nombre_tabla")
- Define el nombre de la tabla en la BD
- Si no se pone, usa el nombre de la clase
Ejemplo: @Table(name = "products")

@Id
- Marca el campo como clave primaria (PRIMARY KEY)
- Obligatorio en cada entidad
Ejemplo: @Id private Long id;

@GeneratedValue(strategy = GenerationType.IDENTITY)
- El valor se genera autom√°ticamente
- IDENTITY usa auto-increment de la base de datos
- Cada vez que insertas un registro, el ID aumenta solo
Ejemplo:
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

@Column
- Configura las propiedades de la columna
- Atributos comunes:
  * nullable = false ‚Üí NO puede ser null (obligatorio)
  * unique = true ‚Üí No puede haber valores duplicados
  * columnDefinition = "TEXT" ‚Üí Para textos largos
  * updatable = false ‚Üí No se puede modificar despu√©s de crear
Ejemplo: @Column(nullable = false, unique = true)

@Enumerated(EnumType.STRING)
- Para guardar enums en la base de datos
- STRING guarda el nombre ("ADMIN", "CUSTOMER")
- ORDINAL guarda el n√∫mero (0, 1, 2...) ‚Üê NO RECOMENDADO
Ejemplo:
  @Enumerated(EnumType.STRING)
  private Role role;

@ManyToOne
- Relaci√≥n de muchos a uno
- Ejemplo: Muchos productos pueden tener UNA categor√≠a
- fetch = FetchType.LAZY ‚Üí No carga los datos hasta que los pidas
- fetch = FetchType.EAGER ‚Üí Carga todo de inmediato
Ejemplo:
  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "category_id")
  private Category category;

@OneToMany
- Relaci√≥n de uno a muchos
- Ejemplo: Una orden tiene MUCHOS items
- mappedBy = "order" ‚Üí Campo en la otra clase que tiene la relaci√≥n
- cascade = CascadeType.ALL ‚Üí Si borras orden, borra los items
- orphanRemoval = true ‚Üí Si quitas un item de la lista, lo borra
Ejemplo:
  @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<OrderItem> items = new ArrayList<>();

@JoinColumn(name = "columna_id")
- Define el nombre de la columna que guarda la relaci√≥n (foreign key)
Ejemplo: @JoinColumn(name = "category_id")

@ElementCollection
- Para guardar una colecci√≥n de valores simples (no entidades)
- Ejemplo: Lista de URLs de im√°genes
Ejemplo:
  @ElementCollection
  @CollectionTable(name = "product_images", joinColumns = @JoinColumn(name = "product_id"))
  @Column(name = "image_url")
  private List<String> images = new ArrayList<>();

@PreUpdate
- M√©todo que se ejecuta autom√°ticamente ANTES de actualizar
Ejemplo:
  @PreUpdate
  protected void onUpdate() {
      updatedAt = LocalDateTime.now();
  }

@JsonIgnoreProperties
- Evita ciclos infinitos al serializar a JSON
- Ignora ciertos campos al convertir a JSON
Ejemplo: @JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})

================================================================================
2. ANOTACIONES LOMBOK
================================================================================

@Getter
- Genera autom√°ticamente TODOS los m√©todos get
- getId(), getName(), getPrice(), etc.
RECOMENDADO: Usar esto en vez de @Data

@Setter
- Genera autom√°ticamente TODOS los m√©todos set
- setId(), setName(), setPrice(), etc.
RECOMENDADO: Usar esto en vez de @Data

@NoArgsConstructor
- Genera un constructor vac√≠o: new Product()
- Necesario para JPA

@AllArgsConstructor
- Genera un constructor con TODOS los par√°metros
- new Product(id, name, price, stock, ...)

@Data
- Genera @Getter + @Setter + @ToString + @EqualsAndHashCode
- ‚ö†Ô∏è NO RECOMENDADO en entidades con relaciones
- Puede causar StackOverflowError con relaciones bidireccionales
- Mejor usar @Getter y @Setter por separado

================================================================================
3. TIPOS DE DATOS IMPORTANTES
================================================================================

Long
- Para IDs (primary keys)
- Permite valores null
Ejemplo: private Long id;

String
- Para textos (nombres, emails, descripciones)
Ejemplo: private String name;

BigDecimal
- Para dinero y valores decimales precisos
- ‚ö†Ô∏è NUNCA uses Double o Float para dinero
- BigDecimal evita errores de redondeo
Ejemplo: private BigDecimal price;

Integer
- Para n√∫meros enteros (stock, cantidad)
Ejemplo: private Integer stock;

Boolean
- Para verdadero/falso (activo, destacado)
Ejemplo: private Boolean active;

LocalDateTime
- Para fechas y horas
- Reemplaza a Date (m√°s moderno)
Ejemplo: private LocalDateTime createdAt;

List<T>
- Para colecciones (listas)
Ejemplo: private List<OrderItem> items = new ArrayList<>();

Optional<T>
- Envoltorio para valores que pueden ser null
- Evita NullPointerException
Ejemplo: Optional<User> findByEmail(String email);

================================================================================
4. RELACIONES ENTRE TABLAS
================================================================================

TIPOS DE RELACIONES:

1. @ManyToOne (Muchos a Uno)
   - Muchas entidades A relacionadas con UNA entidad B
   - Ejemplo: Muchos productos ‚Üí Una categor√≠a
   - La foreign key est√° en la tabla A (products.category_id)

2. @OneToMany (Uno a Muchos)
   - UNA entidad A relacionada con MUCHAS entidades B
   - Ejemplo: Una orden ‚Üí Muchos items
   - Siempre va con mappedBy en el lado "uno"

3. @OneToOne (Uno a Uno)
   - UNA entidad A con UNA entidad B
   - Ejemplo: Un usuario ‚Üí Un perfil
   - Menos com√∫n

4. @ManyToMany (Muchos a Muchos)
   - Muchas A con muchas B
   - Ejemplo: Productos ‚Üî Etiquetas
   - Se crea una tabla intermedia autom√°ticamente

FETCH TYPES:

FetchType.LAZY (Carga perezosa)
- NO carga los datos relacionados hasta que los uses
- Mejora el rendimiento
- RECOMENDADO para @ManyToOne y @OneToMany
- Ejemplo: Al cargar Product, NO carga Category hasta que hagas product.getCategory()

FetchType.EAGER (Carga inmediata)
- Carga TODOS los datos relacionados de inmediato
- Puede afectar el rendimiento
- Usar solo cuando siempre necesites los datos relacionados

CASCADE TYPES:

CascadeType.ALL
- Todas las operaciones se propagan
- Si guardas/borras A, tambi√©n afecta a B

CascadeType.PERSIST
- Al guardar A, guarda B autom√°ticamente

CascadeType.REMOVE
- Al borrar A, borra B autom√°ticamente

CascadeType.MERGE
- Al actualizar A, actualiza B

orphanRemoval = true
- Si quitas un elemento de la colecci√≥n, se borra de la BD
- Ejemplo: Si quitas un OrderItem de la lista, se elimina

================================================================================
5. SPRING DATA JPA - REPOSITORIES
================================================================================

¬øQu√© es un Repository?
- Interfaz que maneja operaciones con la base de datos
- Extiende JpaRepository<Entidad, TipoID>
- Spring genera autom√°ticamente la implementaci√≥n

Ejemplo b√°sico:
public interface ProductRepository extends JpaRepository<Product, Long> {
    // Aqu√≠ defines m√©todos personalizados
}

M√âTODOS QUE TRAE JpaRepository (gratis):

save(entity)
- Guarda o actualiza una entidad
- Si el ID es null ‚Üí INSERT
- Si el ID existe ‚Üí UPDATE

findById(id)
- Busca por ID
- Retorna Optional<Entity>

findAll()
- Trae todos los registros
- Retorna List<Entity>

deleteById(id)
- Elimina por ID

delete(entity)
- Elimina la entidad

count()
- Cuenta todos los registros

existsById(id)
- Verifica si existe un registro con ese ID
- Retorna true o false

================================================================================
6. CONVENCIONES DE NOMBRES EN M√âTODOS
================================================================================

Spring Data JPA genera SQL autom√°ticamente seg√∫n el nombre del m√©todo:

PALABRAS CLAVE:

findBy...
- Buscar registros
Ejemplo: findByName(String name)
SQL: SELECT * FROM tabla WHERE name = ?

findBy...And...
- Buscar con m√∫ltiples condiciones (AND)
Ejemplo: findByNameAndPrice(String name, BigDecimal price)
SQL: SELECT * FROM tabla WHERE name = ? AND price = ?

findBy...Or...
- Buscar con OR
Ejemplo: findByNameOrSku(String name, String sku)
SQL: SELECT * FROM tabla WHERE name = ? OR sku = ?

existsBy...
- Verifica si existe
Ejemplo: existsByEmail(String email)
SQL: SELECT COUNT(*) > 0 FROM tabla WHERE email = ?
Retorna: Boolean (true/false)

countBy...
- Cuenta registros
Ejemplo: countByCategory(Category category)
SQL: SELECT COUNT(*) FROM tabla WHERE category_id = ?

deleteBy...
- Elimina registros que cumplan condici√≥n
Ejemplo: deleteByActiveFlase()
SQL: DELETE FROM tabla WHERE active = false

COMPARADORES:

LessThan
- Menor que
Ejemplo: findByPriceLessThan(BigDecimal price)
SQL: WHERE price < ?

GreaterThan
- Mayor que
Ejemplo: findByStockGreaterThan(Integer stock)
SQL: WHERE stock > ?

Between
- Entre dos valores
Ejemplo: findByPriceBetween(BigDecimal min, BigDecimal max)
SQL: WHERE price BETWEEN ? AND ?

Like / Containing
- Buscar texto que contenga
Ejemplo: findByNameContaining(String keyword)
SQL: WHERE name LIKE %?%

StartingWith
- Que empiece con
Ejemplo: findByNameStartingWith(String prefix)
SQL: WHERE name LIKE ?%

EndingWith
- Que termine con
Ejemplo: findByNameEndingWith(String suffix)
SQL: WHERE name LIKE %?

IgnoreCase
- Ignorar may√∫sculas/min√∫sculas
Ejemplo: findByEmailIgnoreCase(String email)
SQL: WHERE LOWER(email) = LOWER(?)

IsNull / IsNotNull
- Campo null o no null
Ejemplo: findByDiscountPriceIsNotNull()
SQL: WHERE discount_price IS NOT NULL

True / False
- Para booleanos
Ejemplo: findByActiveTrue()
SQL: WHERE active = true

ORDENAMIENTO:

OrderBy...Asc
- Ordenar ascendente (A-Z, 0-9)
Ejemplo: findByActiveTrueOrderByNameAsc()
SQL: WHERE active = true ORDER BY name ASC

OrderBy...Desc
- Ordenar descendente (Z-A, 9-0)
Ejemplo: findByActiveTrueOrderByCreatedAtDesc()
SQL: WHERE active = true ORDER BY created_at DESC

EJEMPLOS COMPLETOS:

findByNameContainingIgnoreCaseAndActiveTrue(String keyword)
SQL: SELECT * FROM tabla
     WHERE LOWER(name) LIKE LOWER(%?%)
     AND active = true

findByCategoryAndPriceBetweenOrderByPriceAsc(Category cat, BigDecimal min, BigDecimal max)
SQL: SELECT * FROM tabla
     WHERE category_id = ?
     AND price BETWEEN ? AND ?
     ORDER BY price ASC

================================================================================
7. CONSULTAS PERSONALIZADAS CON @Query
================================================================================

Cuando el nombre del m√©todo no es suficiente, usa @Query

JPQL (Java Persistence Query Language):
- Es como SQL pero usa nombres de clases y atributos
- No nombres de tablas y columnas

Ejemplo b√°sico:
@Query("SELECT p FROM Product p WHERE p.price > :minPrice")
List<Product> findExpensiveProducts(@Param("minPrice") BigDecimal minPrice);

Partes de la consulta:
- SELECT p ‚Üí Selecciona el producto completo
- FROM Product p ‚Üí De la clase Product (no tabla "products")
- WHERE p.price ‚Üí Atributo price (no columna "price")
- :minPrice ‚Üí Par√°metro nombrado
- @Param("minPrice") ‚Üí Conecta par√°metro del m√©todo con la consulta

JPQL vs SQL:
JPQL: SELECT p FROM Product p WHERE p.category.name = :name
SQL:  SELECT * FROM products p JOIN categories c ON p.category_id = c.id WHERE c.name = ?

Consulta SQL nativa:
@Query(value = "SELECT * FROM products WHERE price > ?1", nativeQuery = true)
List<Product> findExpensiveProductsNative(BigDecimal minPrice);

nativeQuery = true ‚Üí Usas SQL directo de PostgreSQL

FUNCIONES AGREGADAS:

SUM
@Query("SELECT SUM(o.totalAmount) FROM Order o WHERE o.status = 'PAID'")
BigDecimal calculateTotalSales();

COUNT
@Query("SELECT COUNT(p) FROM Product p WHERE p.active = true")
Long countActiveProducts();

AVG
@Query("SELECT AVG(r.rating) FROM Review r WHERE r.product.id = :productId")
Double calculateAverageRating(@Param("productId") Long productId);

MAX / MIN
@Query("SELECT MAX(p.price) FROM Product p")
BigDecimal findMaxPrice();

GROUP BY
@Query("SELECT p.category, COUNT(p) FROM Product p GROUP BY p.category")
List<Object[]> countProductsByCategory();

================================================================================
8. BUENAS PR√ÅCTICAS
================================================================================

ENTIDADES:

‚úÖ Usa @Getter y @Setter en vez de @Data
‚úÖ Usa BigDecimal para dinero, NUNCA Double o Float
‚úÖ Usa FetchType.LAZY para relaciones (mejor rendimiento)
‚úÖ Usa @JsonIgnoreProperties para evitar ciclos infinitos
‚úÖ Usa Optional<T> para valores que pueden no existir
‚úÖ Inicializa colecciones: private List<OrderItem> items = new ArrayList<>();
‚úÖ Usa enums para estados fijos (OrderStatus, Role, etc.)
‚úÖ Marca campos de auditor√≠a como updatable = false (createdAt)

‚ùå NO uses @Data en entidades con relaciones
‚ùå NO uses fetch = EAGER sin una buena raz√≥n
‚ùå NO uses imports con wildcard (import java.util.*)
‚ùå NO guardes contrase√±as en texto plano (siempre encriptadas)
‚ùå NO uses EnumType.ORDINAL (usa STRING)

REPOSITORIES:

‚úÖ Usa nombres descriptivos en m√©todos
‚úÖ Retorna Optional cuando puede no existir
‚úÖ Usa @Query para consultas complejas
‚úÖ Usa @Param para nombrar par√°metros claramente
‚úÖ Aprovecha las convenciones de Spring (findBy, existsBy, etc.)

‚ùå NO hagas consultas complejas en el controller
‚ùå NO retornes null, usa Optional

NOMENCLATURA:

‚úÖ Entidades: Singular, PascalCase ‚Üí Product, OrderItem, User
‚úÖ Tablas: Plural, snake_case ‚Üí products, order_items, users
‚úÖ Atributos: camelCase ‚Üí firstName, totalAmount, createdAt
‚úÖ Columnas: snake_case ‚Üí first_name, total_amount, created_at
‚úÖ M√©todos: verbos + sustantivos ‚Üí findByEmail, calculateTotal

SEGURIDAD:

‚úÖ Valida SIEMPRE los datos de entrada
‚úÖ Usa @Valid en los controllers
‚úÖ Encripta contrase√±as con BCrypt
‚úÖ No expongas IDs internos sensibles
‚úÖ Usa DTOs para transferir datos (no expongas entidades directamente)

RENDIMIENTO:

‚úÖ Usa FetchType.LAZY por defecto
‚úÖ Usa paginaci√≥n para listas grandes (Pageable)
‚úÖ Indexa columnas que se buscan frecuentemente
‚úÖ Evita N+1 queries (usa JOIN FETCH cuando sea necesario)

================================================================================
COMANDOS √öTILES MAVEN
================================================================================

mvn clean install
- Limpia y compila el proyecto

mvn spring-boot:run
- Ejecuta la aplicaci√≥n

mvn test
- Ejecuta los tests

================================================================================
RECURSOS ADICIONALES
================================================================================

Documentaci√≥n oficial:
- Spring Data JPA: https://spring.io/projects/spring-data-jpa
- JPA Annotations: https://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html
- Lombok: https://projectlombok.org/

Query Methods:
https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods

================================================================================
                            FIN DE APUNTES
================================================================================